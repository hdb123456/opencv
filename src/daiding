#include <opencv2/opencv.hpp>
#include <linux/videodev2.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <cmath>
#include <main.h>
#include "circle_detection.h"

void Dilation(int, void*);
void Erosion(int, void*);
void Morphology_Operations(int, void*);
double angle(Point pt1, Point pt2, Point pt0);
void findSquares(const Mat& image, vector<vector<Point>>& squares);
void create_windows(void);
int video_start(void);
void cleanup(int fd, void** buffers, int buffer_count);
void adjust(int, void*);

int main(int argc, char *argv[]) 
{
	return video_start();
}

// 形态学膨胀操作的回调函数
void Dilation(int, void*) {
    int dilation_type = dilation_elem == 0 ? MORPH_RECT :
                        dilation_elem == 1 ? MORPH_CROSS : MORPH_ELLIPSE;
    Mat element = getStructuringElement(dilation_type,
                                        Size(2 * dilation_size + 1, 2 * dilation_size + 1),
                                        Point(dilation_size, dilation_size));
    dilate(dst, dst, element);
    imshow(dilation_name, dst);
}

// 形态学腐蚀操作的回调函数
void Erosion(int, void*) {
    int erosion_type = erosion_elem == 0 ? MORPH_RECT :
                       erosion_elem == 1 ? MORPH_CROSS : MORPH_ELLIPSE;
    Mat element = getStructuringElement(erosion_type,
                                        Size(2 * erosion_size + 1, 2 * erosion_size + 1),
                                        Point(erosion_size, erosion_size));
    erode(src, erosion_dst, element);
    imshow(Erosion_name, erosion_dst);
}

// 计算三个点形成的角度
double angle(Point pt1, Point pt2, Point pt0) {
    double dx1 = pt1.x - pt0.x;
    double dy1 = pt1.y - pt0.y;
    double dx2 = pt2.x - pt0.x;
    double dy2 = pt2.y - pt0.y;
    return (dx1 * dx2 + dy1 * dy2) / sqrt((dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2));
}

// 找到图像中的矩形轮廓
void findSquares(const Mat& image, vector<vector<Point>>& squares) {
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(image, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE);
    
    vector<Point> approx;
    for (size_t i = 0; i < contours.size(); i++) {
        // 只处理内部轮廓
        if (hierarchy[i][2] == -1) continue;
        
        approxPolyDP(contours[i], approx, arcLength(contours[i], true) * 0.02, true);
        if (approx.size() == 4 && fabs(contourArea(approx)) > 1000 ) {
            double maxCosine = 0;
            for (int j = 2; j < approx.size(); j++) {
                double cosine = fabs(angle(approx[j % approx.size()], approx[j - 2], approx[j - 1]));
                maxCosine = MAX(maxCosine, cosine);
            }
            if (maxCosine < 0.5) {
                // 计算矩形的重心
                Moments m = moments(approx, true);
                Point center(m.m10/m.m00, m.m01/m.m00);
                // 如果中心在图像的中间区域
                if (center.x > image.cols / 4 && center.x < 3 * image.cols / 4 &&
                    center.y > image.rows / 4 && center.y < 3 * image.rows / 4) {
                    squares.push_back(approx);
                }
            }
        }
    }
     // 仅保留最里面的轮廓
    if (squares.size() == 2) {
        squares.erase(squares.begin());
    } 
}


// 形态学操作的回调函数
void Morphology_Operations(int, void*) {
    // 选择形态学操作类型
    int operation = morph_operator + 2;
 
    Mat element = getStructuringElement(morph_elem, Size(2 * morph_size + 1, 2 * morph_size + 1), Point(morph_size, morph_size));
 
    morphologyEx(dst, dst, operation, element);
    imshow(morph_name, dst);
}

void create_windows(void)
{
        // 创建窗口
        namedWindow(window_name, WINDOW_AUTOSIZE);
        namedWindow(dilation_name, WINDOW_AUTOSIZE);
        namedWindow(Erosion_name, WINDOW_AUTOSIZE);
        namedWindow(morph_name, WINDOW_AUTOSIZE); // Create window
		namedWindow(redpoint, WINDOW_AUTOSIZE);
		
        // 创建滚动条
        createTrackbar("Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", dilation_name, &dilation_elem, max_elem, Dilation);
        createTrackbar("Kernel size:\n 2n +1", dilation_name, &dilation_size, max_kernel_size, Dilation);
        createTrackbar("Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", Erosion_name, &erosion_elem, max_elem, Erosion);
        createTrackbar("Kernel size:\n 2n +1", Erosion_name, &erosion_size, max_kernel_size, Erosion);
        createTrackbar("Operator:\n 0: Opening - 1: Closing \n 2: Gradient - 3: Top Hat \n 4: Black Hat", morph_name, &morph_operator, max_operator, Morphology_Operations);
        createTrackbar("Element:\n 0: Rect - 1: Cross - 2: Ellipse", morph_name, &morph_elem, max_elem, Morphology_Operations);
        createTrackbar("Kernel size:\n 2n +1", morph_name, &morph_size, max_kernel_size, Morphology_Operations);
        
        createTrackbar("LOW1_H", redpoint, &LOW1_H, MAX_COLOR, adjust);
        createTrackbar("LOW1_S", redpoint, &LOW1_S, MAX_SV, adjust);
        createTrackbar("LOW1_V", redpoint, &LOW1_V, MAX_SV, adjust);
       	createTrackbar("UP1_H", redpoint, &UP1_H, MAX_COLOR, adjust);
        createTrackbar("UP1_S", redpoint, &UP1_S, MAX_SV, adjust);
        createTrackbar("UP1_V", redpoint, &UP1_V, MAX_SV, adjust);
        
        createTrackbar("LOW2_H", redpoint, &LOW2_H, MAX_COLOR, adjust);
        createTrackbar("LOW2_S", redpoint, &LOW2_S, MAX_SV, adjust);
        createTrackbar("LOW2_V", redpoint, &LOW2_V, MAX_SV, adjust);
        createTrackbar("UP2_H", redpoint, &UP2_H, MAX_COLOR, adjust);
        createTrackbar("UP2_S", redpoint, &UP2_S, MAX_SV, adjust);
        createTrackbar("UP2_V", redpoint, &UP2_V, MAX_SV, adjust);		
}

void adjust(int, void*)
{
	Scalar lower_red1(LOW1_H, LOW1_S, LOW1_V);
	Scalar upper_red1(UP1_H, UP1_S, UP1_V);
	
	Scalar lower_red2(LOW2_H, LOW2_S, LOW2_V);
	Scalar upper_red2(UP2_H, UP2_S, UP2_V);
	
	inRange(hsv_img, lower_red1, upper_red1, mask1);
	inRange(hsv_img, lower_red2, upper_red2, mask2);
	bitwise_or(mask1, mask2, mask);
	imshow("mask",mask);
}

int video_start(void)
{
    // 打开视频设备
    if ((fd = open("/dev/video4", O_RDWR)) == -1) {
        perror("open video device failed");
        return 1;
    }

    // 查询视频设备功能
    if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == -1) {
        perror("query video device capability failed");
        close(fd);
        return 1;
    }

    // 设置视频格式
    memset(&fmt, 0, sizeof(fmt));
    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    fmt.fmt.pix.width = 640;
    fmt.fmt.pix.height = 480;
    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
    fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
    if (ioctl(fd, VIDIOC_S_FMT, &fmt) == -1) {
        perror("set video format failed");
        close(fd);
        return 1;
    }
    
     // 设置帧率
    struct v4l2_streamparm parm;
    memset(&parm, 0, sizeof(parm));
    parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    parm.parm.capture.timeperframe.numerator = 1;
    parm.parm.capture.timeperframe.denominator = 60; // 设置帧率为60 fps

    if (ioctl(fd, VIDIOC_S_PARM, &parm) == -1) {
        perror("set frame rate failed");
        close(fd);
        return 1;
    }

    // 请求视频缓冲区
    memset(&reqbuf, 0, sizeof(reqbuf));
    reqbuf.count = 4;
    reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    reqbuf.memory = V4L2_MEMORY_MMAP;

    if (ioctl(fd, VIDIOC_REQBUFS, &reqbuf) == -1) {
        perror("request video buffer failed");
        close(fd);
        return 1;
    }

    // 映射缓冲区到用户空间
    void* buffers[4];
    for (int i = 0; i < reqbuf.count; ++i) {
        memset(&buf, 0, sizeof(buf));
        buf.index = i;
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory = V4L2_MEMORY_MMAP;

        if (ioctl(fd, VIDIOC_QUERYBUF, &buf) == -1) {
            perror("query video buffer failed");
            close(fd);
            return 1;
        }

        buffers[i] = mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset);
        if (buffers[i] == MAP_FAILED) {
            perror("mmap video buffer failed");
            close(fd);
            return 1;
        }
    }

    // 将缓冲区入队
    for (int i = 0; i < reqbuf.count; ++i) {
        memset(&buf, 0, sizeof(buf));
        buf.index = i;
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory = V4L2_MEMORY_MMAP;
        if (ioctl(fd, VIDIOC_QBUF, &buf) == -1) {
            perror("enqueue video buffer failed");
            close(fd);
            return 1;
        }
    }

    // 启动视频捕捉
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (ioctl(fd, VIDIOC_STREAMON, &type) == -1) {
        perror("start video capture failed");
        close(fd);
        return 1;
    }
    // 设置自动白平衡
    struct v4l2_control ctrl;
    ctrl.id = V4L2_CID_AUTO_WHITE_BALANCE;
    ctrl.value = 0; // 0 表示关闭自动白平衡
    if (ioctl(fd, VIDIOC_S_CTRL, &ctrl) == -1) {
        perror("set auto white balance failed");
        close(fd);
        return 1;
    }
    
    create_windows();//创造窗口
    
    while (true) 
		{
			    fd_set fds;
			    FD_ZERO(&fds);
			    FD_SET(fd, &fds);
			    timeval tv = {2, 0};
			    int r = select(fd + 1, &fds, NULL, NULL, &tv);

			    if (r == -1) {
			        perror("select failed");
			        break;
			    }
			    if (r == 0) {
			        printf("select timeout\n");
			        break;
			    }

			    // 取出缓冲区
			    memset(&buf, 0, sizeof(buf));
			    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
			    buf.memory = V4L2_MEMORY_MMAP;
			    if (ioctl(fd, VIDIOC_DQBUF, &buf) == -1) {
			        perror("dequeue video buffer failed");
			        continue;
			    }

			    unsigned char* frame = (unsigned char*)buffers[buf.index];
			    Mat yuyv_img(Size(640, 480), CV_8UC2, frame);
			    // 色彩转换
			    cvtColor(yuyv_img, src, COLOR_YUV2BGR_YUYV);
			    imshow("src", src);
			    
			    // 色彩校正（根据需要调整），提高对比度
			    Mat lookupTable(1, 256, CV_8U);
			    uchar* p = lookupTable.ptr();
			    for (int i = 0; i < 256; ++i)
			        p[i] = (uchar)(pow((double)i / 255.0, 1.2) * 255.0); // Gamma correction
			    LUT(src, lookupTable, src);
			    
			  
			     // 边缘检测
                //Mat gray;
                //cvtColor(src, gray, COLOR_BGR2GRAY);
                
				cvtColor(src, hsv_img, COLOR_BGR2HSV);
				imshow("hsv_img",hsv_img);
				cv::Mat blurredImage;
				cv::GaussianBlur(hsv_img, hsv_img, cv::Size(3, 3), 0);
				imshow("blurredImage",hsv_img);	
				adjust(0, 0);
		    
                //Mat blurred;
                //GaussianBlur(gray, blurred, Size(3, 3), 3);
			    Canny(mask, dst, 50, 100, 3);
			    
				// 形态学去噪
				Morphology_Operations(0, 0);
				//膨胀
				Dilation(0, 0);
				
		    
		    
		    // 绘制矩形轮廓   
			vector<vector<Point>> squares;
			findSquares(dst, squares);
			
			for (const auto& square : squares) 
			{
				polylines(src, square, true, Scalar(0, 255, 0), 1, LINE_AA); // 使用抗锯齿绘制

				for (size_t i = 0; i < square.size(); ++i) 
				{
					// 画角点
					circle(src, square[i], 2, Scalar(0, 0, 255), -1); // 红色圆点
					// 添加角点坐标
					putText(src, "(" + to_string(square[i].x) + ", " + to_string(square[i].y) + ")", square[i], FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 255, 0), 1);
					// 计算两个角点之间的等距离点
					Point pt1 = square[i];
					Point pt2 = square[(i + 1) % square.size()]; // 环绕到第一个点
					int num_points = 4; // 需要在两个角点之间绘制的点的数量
					for (int j = 1; j < num_points; ++j) {
							float ratio = static_cast<float>(j) / num_points;
							Point pt = pt1 + (pt2 - pt1) * ratio; // 线性插值计算中间点
							circle(src, pt, 2, Scalar(0, 0, 255), -1); // 红色圆点
							putText(src, "(" + to_string(pt.x) + ", " + to_string(pt.y) + ")", pt, FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 255, 0), 1);
					}
				}
			}
	/*	
	// 查找白色棋子
	cvtColor(src, hsv_img, COLOR_BGR2HSV);
	// 白色棋子范围
	adjust(0, 0);
	// 形态学操作去噪
	Mat kernel = getStructuringElement(MORPH_ELLIPSE, Size(5, 5));
	morphologyEx(mask, mask, MORPH_CLOSE, kernel);
	morphologyEx(mask, mask, MORPH_OPEN, kernel);
   
    vector<vector<Point>> laser_contours;
    findContours(mask, laser_contours, RETR_TREE, CHAIN_APPROX_SIMPLE);

    for (const auto& contour : laser_contours) {
        Moments m = moments(contour);//计算矩
        if (m.m00 > 10) { // 排除面积过小的轮廓
            Point center(m.m10 / m.m00, m.m01 / m.m00);//获取质心
            //轮询检查每个方格
            ==========加入方格坐标循环============
		        //检查白色棋子是否在棋盘轮廓内部或边缘
		        bool is_inside = false;
		        for (const auto& square : squares) {
		            double result = pointPolygonTest(square, center, false);
		            if (result >= 0) { // 在内部或边缘
		                is_inside = true;
		                break;
		            }
		        }
            if (is_inside) {
                circle(src, center, 5, Scalar(0, 255, 255), -1); // 画出激光点
                putText(src, "(" + to_string(center.x) + ", " + to_string(center.y) + ")", center, FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 255, 255), 1);
                printf("Detected laser point at: (%d, %d)\n", center.x, center.y);
            }
        }
    }
    
    //黑色棋子部分
    0.0.180
    160.60.200
    
*/
			imshow("hello", src);
			        
		    // 将缓冲区重新入队
		    if (ioctl(fd, VIDIOC_QBUF, &buf) == -1) {
		        perror("enqueue video buffer failed");
		        break;
		    }

		   if (waitKey(30) == ' ') break;
	}
		cleanup(fd, buffers, reqbuf.count);
		return 0;
}

//关闭相机输入通道
void cleanup(int fd, void** buffers, int buffer_count) {
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (ioctl(fd, VIDIOC_STREAMOFF, &type) == -1) {
                        perror("stop video capture failed");
        }
    for (int i = 0; i < buffer_count; ++i) {
        munmap(buffers[i], buf.length);
    }
    close(fd);
}
